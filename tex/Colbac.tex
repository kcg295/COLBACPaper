\subsection{COLBAC: Collective Based Access Control}
\label{sec:colbac}
As discussed in previous sections, the choice of certain software, protocols, or
techniques such as X509 certificates or PGP web of trust has implications in the
level of horizontality possible for systems built on top of those software,
protocols, or techniques. How, then, can we build a foundation such that
organizations of different horizontality can use the same foundation and arrive
at much differently structured organizations?

In this section we describe our Collective Based Access Control, or COLBAC: our
approach to a dynamic horizontality access control system. We begin by
describing its requirements, focusing on the dynamic horizontality that
separates COLBAC from other access control systems. We then define the system
itself. Finally, we discuss the properties of this system and the limitations of
this system.

\subsubsection{System Requirements}
\mbox{}\\
COLBAC is aimed at addressing a novel requirement in cybersecurity research:
access control and authorization given an organization with dynamic levels of
horizontal control. Though previous approaches exist for hierarchical access
control (such as MAC, RBAC, etc.), to our knowledge no access control model
exists for organizations of dynamic and flexibile horizontality. To realize
this, our solution must be able to be flexible in terms of horizontality. Said
another way, our system must not assume or define a pre-determined threshold for
horizontal control, i.e., it must not assume majority, or super-majority, or
full consensus is the preferred method of democratic participation. Instead,
the threshold must be configured by the collective itself, and must be able to
be changed when necessary. This allows for rapid temporary centralization of the
system to respond to crises, or to perform a task that requires expertise that
few members of the collective contain. However, these moments of centralization
must be quick to expire and easy to override in order to prevent abuse of
centralized power. Said another way, it must always be easy for the collective
to return to more horizontal control.

However, it makes no sense to have horizontal or democratic control without
transparency. An individual cannot meaningfully vote or otherwise decide on a
practice, or place confidence in a representative, without understanding what
the action is going to take place, and what actions have been taken in the past.
More, if authority is abused, the collective must be able to notice the abuse,
and remove the powers that allowed the abuse to take place. Thus, we can see
that any horizontal access control system requires transparency. Towards this
end, our system must have a method of logging information about the actions of
individuals and the collective that is immutable and available.

\subsubsection{System Design}
\mbox{}\\
COLBAC presents a solution to access control that relies around the collective.
However, as will be discussed later in this section, not all objects on the
system will need to be collectively controlled or administered. As such, we
define three distinct \textit{spheres} of the system, or areas that require
different approaches to access control. These spheres are the \textbf{Collective
Sphere}, the \textbf{User Spheres}, and the \textbf{Immutable Sphere}.

In order to achieve different degrees of horizontality, there must be a portion
of the system that is controlled not by any individual user of the system, but
by some democratic process of the users of the system. We call this portion of
the system the \textbf{Collective Sphere}, as it contains programs, files, and
other resources only accessed based on collective authorization. In any
horizontal system, the administrative functions of the operating system would
need to exist within this portion of the system to allow for true collective
control.

However, not everything should be directly managed by the collective. Individual
users may have their own files and programs they intend to use only in a way
that it does not effect other users of the system or the resources of the
collective\footnote{We can think of these as the home directories of users in
modern Unix-like systems.}. This spehere, called the \textbf{User Spehere},
can use traditional DAC systems like modern Unix-like systems without effecting
the horizontality of the system as a whole.

Finally, to have meaningful control of the system we must have transparency. To
achieve this, a system must have an \textbf{Immutable Sphere}, or a portion of
the file system and programs that cannot be altered once written to, including
by democratic control. This allows for the system to provide append only logs
that are vital to maintaining collective control, as described later in this
section.

When the system is first installed, a \textit{Registration Phase} will occur.
During this phase, at least 3 users will be signed up in the system. These users
will need to supply their public keys, which correspond to offline private keys,
since they will be needed for later interactions with the system. In addition to
supplying their public keys, the users will need to decide on an initial
fraction $f$ and a minimum fraction $m$ that will be used for action and
delegation petitions, as explained later.

After the system is set up, users can interact with objects in the User Sphere
as they would in any other system. However, to interact with any objects in the
Collective Sphere, users would need to follow a specific authorization
procedure consisting of three phases: the \textit{Draft Phase}, the 
\textit{Petition Phase}, and the \textit{Action Phase}.

In the Draft Phase, depending on the action the user wishes to perform, they
will write the code or commands that will interact with objects in the
Collective Sphere, or will identify the permissions they will need to accomplish
their task or tasks. At the end of this process, the user will have a draft
Action or Delegation token, as described later in Sections \ref{sec:tokentypes}
and \ref{sec:tokenformat}.

After the user has completed their token, they move on to the Petition Phase. In
this phase the user sends their draft token to the reference monitor running on
the system. This reference monitor will then forward the draft token to all
other members of the system and ask for a vote. The users will then vote one of
the following ways: yes, no, or abstain. The system will set a pre-configured
amount of time before marking all individuals who did not vote as abstaining.

After all votes are collected or the response period has timed out, the system
enters the action phase. During the action phase the reference monitor counts
all of the votes. If the number of votes divided by the total number of users is
greater than or equal to $m$, and the fraction of yes votes to the total number
of votes is greater than or equal to $f$, the petition is considered successful
and the action is taken. In addition to taking the action, the system logs the
action in log files held in the immutable sphere. However, if the number of all
votes divided by the total number of users is less than $m$ or if the number of
yes votes divided by the total number of votes is less than $f$, the petition
fails, and the attempted action is logged in the immutable spehere.

\subsubsection{Types of Tokens}
\label{sec:tokentypes}
\mbox{}\\
As the previous section demonstrates, the token is the main form of interacting
with the Collective Sphere. Users who wish to affect the Collective Sphere do
so by creating a token which is then voted on by the users of the system. In
order to facilitate easy interaction with the colbac system, there are multiple
types of tokens.

The first token is called the \textbf{Action Token}. This token allows a single
command, a small script, or a program to be run in the Collective Sphere, and to
enjoy Collective Sphere access. This is the most straightforward type of token,
since everything the token will allow to occur is known during the Petition
Phase. However, this type of token is rigid and unflexible. If there is an error
in the command, or in the code, a user would need to re-enter the Draft Phase,
fix the error, and re-enter the Petition Phase to authorize a new token. The
more a single Action Token attempts to do, the more likely there will be errors,
causing frustration for both the users drafting the tokens and the users voting
on them.

To avoid these issues, COLBAC also allows for \textbf{Delegation Tokens}, which
allow the drafting user to act in the Collective Sphere for a given set of time,
and with a given set of restrictions. The procedure is obtaining a Delegation
Token is the same as that for an Action Token. However, the information that
would be put in the token would be slightly different. The format for Action
Tokens and Delegation Tokens are shown in Section~\ref{sec:tokenformat}.

There are some instances in which one needs to respond to emergency situations
as soon as possible, and cannot wait for a slow authorization process by a
potentially large set of users. To accomidate these situations, COLBAC has an
\textbf{Emergency Token}. These tokens allow users to run short scripts, single
commands, or small programs in the Collective Sphere without immediate
auhorization. However, this action is immediately logged and all users are
informed by the Reference Monitor that an Emergency Token was used. In the case
that an Emergency Token was incorrectly used (say, to overwrite the result of
a democractically made decision), a member can create a new Action Token to
undo the actions of the Emergency Token, which will be pushed to a Petition
Phase for democractic decision making. To avoid large-scale misuse of the
Emergency Token, and to avoid Emergency Token Wars\footnote{We define Emergency
Token Wars as instances in which different members in the organization use
Emergency Tokens to undo the actions taken in the name of the collective.},
each member only has a small number of emergency tokens for a given period of
time. Additionally, there can be limits placed on what can be done with 
Emergency Tokens.

\subsubsection{Token Format}
\label{sec:tokenformat}
\mbox{}\\
Each token contains three sections, a header, a body, and a footer. Different
types of tokens (action tokens, delegation tokens, or emergency tokens) contain
different fields in their body sections. However, the headers and footers of all
token types contain the same fields. For a graphical representation of the token
format, please see Figure~\ref{fig:tokenformatfigure}.

The first portion of a token is called the header. The header contains the
following fields:
%Header:
\begin{enumerate}
\item \textbf{Nonce/ID}:\\ 
An integer used to both identify the token and avoid replay attacks.
\item \textbf{Token Type}:\\ 
The type of token. Can only be Action, Delegation, or Emergency.
\item \textbf{Party(s) Being Authorized}:\\
A single entity or set of entities requesting aurhotization to perform an action
or set of actions in the Collective Sphere.
\item \textbf{Petitioning Party}:\\
The single entity petitioning for authorization. This user usually also exists
in the list of parties being authorized.
\item \textbf{Token Expiration}:\\
The expertation time of the token in Unix format.
\end{enumerate}

For Action Tokens or Emegency Tokens, the token body contains the following
fields:
\begin{enumerate}
\item \textbf{Code to be Run}:\\
The command, script, or program to be run in the Collective Sphere.
\item \textbf{Permissions Requested}:\\
A set of permissions requested to complete the task. These permissions include
negative and positive permissions, of which negative permissions take
precidence. The inclusion of both negative and positive permissions make it
easier for permissions to be specified. For example, if a folder in the
Collective Sphere contains 950 files, and the code running needs read access to
940 of them, it is easier to specify positive read permissions on the whole
folder and negative read permissions on the 10 files, rather than specify 940
positive read permissions and no negative read permissions.
\item \textbf{Comments (optional)}:\\
Comments explaining what the code included in the Token does, and why it is
necessary. This field is similar to messages included in version control systems
like a Git commit message.
\end{enumerate}

For Delegation Tokens, the body contains the following fields:
\begin{enumerate}
\item \textbf{Permissions Needed}:\\
Similar to the set of permissions requested in the Action or Emergency Token
body.
\item \textbf{Comments (optional)}:\\
Similar to the comments section of the Action or Emergency Token body.
\end{enumerate}

As we can see, the Delegation Token body is similar to the Action or Emergency
Token body, except in that it does not specify the code that is running. This
design is ideal for sessions that require troubleshooting, or tasks that may
require back-and-forth between the system and the individual or group performing
the task in order to fully realize. However, when using Delegation Tokens it is
more important to ensure that the Permissions Needed section follows the
principle of least privilege. If not, individuals can use the privileges they
gain from the Delegation Token to perform actions that were not originally
intended for their task(s). Though these actions will be logged into the
Immutable sphere, it still requires time and effort of the system users to undo
the actions of an individual who abused the power granted to them through
Delegation Tokens.

Each token, regardless of type, ends with a footer. The footer simply contains
one field, a field which states if it is approved or denied, along with a
verifiable authentication value that is difficult to predict and easy to verify,
such as an HMAC of the permission token keyed by a secret value known only to
the Reference Monitor.

\subsubsection{Formalizing COLBAC}
\mbox{}\\
\begin{itemize}
\item So much to do here.
\item Let $u$ be the user attempting access.
\item Let $o$ be the object or set if objects the user is attempting to
access.
\item Let $p$ be the set of permissions the user is requesting.
\item Let $t$ be the type of Token the user is attempting to create.
\item Let $e$ be the proposed expiration time of the Token.
\item Let $c$ be the comment attached to a Token, or in the case it doesn't
exist, let $c$ be $NULL$.
\item Let $a$ be the command, script, or program the user wants to run in
the Collective Sphere, or in the case that it doesn't exist, let $a$ be $NULL$.
\item Let $d$ be the set of delegate the user is proposing, or in the case
where it doesn't exist, let $d$ be $NULL$.
\item $DT_{a}(u,o,p,e,a,c) \rightarrow T_{a} = (u,o,p,e,a,c)$
\item $DT_{d}(u,o,p,e,a,c) \rightarrow T_{d} = (u,o,p,e,d,c)$
\item $DT_{e}(u,o,p,a,c) \rightarrow T_{e} = (u,o,p,a,c)$
\item $DT(u,o,p,e,a,c,t) \rightarrow T$ of type $T_{a}$ or $T_{d}$ or $T_{e}$.
\item $P(T) \rightarrow \{ $ set of votes $V$ on authorizing $T$ iff $T$ is of
type $T_{a}$ or $T_{d}$\}.
\item $V_{T} = P(T)$
\item $V_{(T, Yes)} = \{v \in V$ s.t. $v = True\}.$
\item $V_{(T, No)} = \{v \in V$ s.t. $v = False\}.$
\item $V_{(T, Blank)} = \{v \in V$ s.t. $v = NULL\}$.
\item $AT(T,V_{T}) \rightarrow True$ iff $|V_{(T, Yes)}| \ge f \wedge
|V_{(T,Yes)} \bigcup V_{(T, No)}| \ge m$, else $False$.
\item $GTT(t:Token) \rightarrow \{$the type of Token from $Action, Delegation,\\
or Emergency$\}.
\item $GS(o:Object) \rightarrow U$ iff $o \in U$, $C$ iff $o \in C$, $I$ iff
$o \in I$.
\item include algorithm that ties everything together.
\end{itemize}
\begin{algorithm}
\caption{The main decision making process of COLBAC}
\begin{algorithmic}[1]
\If{$GS(o)=U$}
    \State Perform DAC Access Control.
\ElsIf{$GS(o)=C$}
    \State $T = DT(u,o,p,t,e,c,a,d)$
    \If{$GTT(T) \in (T_{a}, T_{d})$}
        \State $V_{T} = P(T)$
        \State $V_{(T, Yes)} = \{v \in V$ s.t. $v = True\}.$
        \State $V_{(T, No)} = \{v \in V$ s.t. $v = False\}.$
        \State $V_{(T, Blank)} = \{v \in V$ s.t. $v = NULL\}$.
        \If{$AT(T, V_{(T, Yes)}, V_{(T, No)}, V_{(T, Blank)},f, m)$}
            \State Perform($T$)
            \State Log($T$, $True$)
        \Else
            \State Log($T$, $False$)
        \EndIf
    \Else
        \State Perform($T$)
        \State LogEmergency($T$)
    \EndIf
\Else
    \State TODO: Fill me in.
\EndIf
\end{algorithmic}
\end{algorithm}


\EndIf

\subsubsection{Properties of COLBAC}
\mbox{}\\
\begin{enumerate}
\item flexible and dynamic horizontality through configurable fraction.
\item full transparency of actions taken.
\item Inclusion of Immutable Section allows for inalienable rights.
\end{enumerate}

\subsubsection{Limitations of COLBAC}
\mbox{}\\
\begin{enumerate}
\item USABILITY!!!!!!!
\end{enumerate}
